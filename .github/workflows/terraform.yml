name: Terraform Destroy and Deploy

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  terraform:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v1
        with:
          terraform_version: 1.0.11
          
      - name: Initialize Terraform
        working-directory: ./terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: terraform init

      - name: Initialize Terraform
        working-directory: ./terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          terraform init \
            -backend-config="access_key=$AWS_ACCESS_KEY_ID" \
            -backend-config="secret_key=$AWS_SECRET_ACCESS_KEY"
      
            - name: Destroy existing infrastructure
              working-directory: ./terraform
              env:
                TF_VAR_aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
                TF_VAR_aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                TF_VAR_key_name: "your-key-name"
              run: terraform destroy -auto-approve
              continue-on-error: true

      - name: Terraform Plan
        working-directory: ./terraform
        env:
          TF_VAR_aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
          TF_VAR_aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_key_name: "your-key-name"
        run: terraform plan

      - name: Apply Terraform
        if: github.ref == 'refs/heads/main'
        working-directory: ./terraform
        env:
          TF_VAR_aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
          TF_VAR_aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_key_name: "your-key-name"
        run: terraform apply -auto-approve

      # Step to retrieve the EC2 instance's public IP
      - name: Get EC2 Public IP
        id: get_ip
        working-directory: ./terraform
        run: |
          instance_ip=$(terraform output -raw instance_public_ip)
          echo "INSTANCE_IP=$instance_ip" >> $GITHUB_ENV

      # Debug step to print the EC2 IP.
      - name: Debug EC2 IP
        run: echo "The EC2 instance IP is ${{ env.INSTANCE_IP }}"

      # Step to wait for the EC2 instance to be ready
      - name: Wait for EC2 instance to be ready
        run: |
          timeout 300 bash -c 'while ! nc -z ${{ env.INSTANCE_IP }} 22; do echo "Waiting for EC2 instance to be ready..."; sleep 10; done'

      # Step to copy necessary files to EC2
      - name: Copy files to EC2
        env:
          PRIVATE_KEY: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        run: |
          echo "$PRIVATE_KEY" > private_key.pem
          chmod 600 private_key.pem
          scp -i private_key.pem -o StrictHostKeyChecking=no -r docker-compose.yaml .env airflow dags Dockerfile app requirements.txt ubuntu@${{ env.INSTANCE_IP }}:~/

      # Step to set up and deploy services using Docker Compose on the EC2 instance
      - name: Setup and deploy services
        env:
          PRIVATE_KEY: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        run: |
          ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@${{ env.INSTANCE_IP }} '
            sudo docker-compose up -d
          '

      # Step to check the health of the services running on the EC2 instance
      - name: Check service health
        env:
          PRIVATE_KEY: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        run: |
          ssh -i private_key.pem -o StrictHostKeyChecking=no ubuntu@${{ env.INSTANCE_IP }} '
            sudo docker-compose ps
            curl -s http://localhost:8080/health || echo "Airflow health check failed"
            curl -s http://localhost:9200 || echo "Elasticsearch check failed"
            curl -s http://localhost:8001/health || echo "FastAPI health check failed"
          '
